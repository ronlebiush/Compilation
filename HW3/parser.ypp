%{
    #include <iostream>
    #include <stdlib.h>
    using namespace std;
    #include "source.hpp"
    #include "output.hpp"
    #include "hw3_output.hpp"

    extern int yylex();
    extern int yylineno;
    int yyerror(const char* message);
    Symtab symtable;

    void closeScope(){
        if(!symtable.tableStack.empty()){
                symtable.printSymtab(symtable.tableStack.top());
                symtable.tableStack.pop();
                symtable.offsetsStack.pop();
        }
    }
%}








%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc LBRACE;
%nonassoc RBRACE;
%nonassoc ID;
%nonassoc NUM;
%nonassoc STRING;
%nonassoc COMMENT;
%right ASSIGN;
%left OR;
%left AND;
%left EQUAL;
%left RELATIONAL;
%left BINOP;
%left MULT;
%right IF;
%right NOT;
%left RPAREN;
%left LPAREN;
%right ELSE;

%%

program:    statements 
            {output::printProductionRule(1);};

statements: statement 
            {output::printProductionRule(2);};

statements: statements statement 
            {output::printProductionRule(3);};

statement:  LBRACE openScopeMarker statements RBRACE 
            {
                closeScope();
                output::printProductionRule(4);
            }

openScopeMarker:          %empty
                        {
                            if(symtable.tableStack.empty()){
                                symtable.printSymtab(symtable.addTable(symtable.root));

                            } 
                            else {
                                symtable.printSymtab(symtable.addTable(symtable.tableStack.top()));
                                }
                            };

statement:  type ID SC 
            {symtable.tableStack.top()->addEntry($2->print_Node(), $1->print_Node(), symtable.offsetsStack.top()++);
            output::printProductionRule(5);};

statement:  type ID ASSIGN exp SC 
            {   
                string type1 = $1->print_Node();
                string type2 = $4->print_Node();
                if((type1 != type2) && !(type1=="INT" && type2=="BYTE")){
                    output::errorMismatch(yylineno);
                    exit(1);
                }
                
                symtable.tableStack.top()->addEntry($2->print_Node(), $1->print_Node(), symtable.offsetsStack.top()++);
                output::printProductionRule(6);};

statement:  ID ASSIGN exp SC
            {   
                Symtab::Table::Entry* entry = symtable.find($1->print_Node());
                if(!entry){

                }
                string type1 = ((IdNode*)$1)->type;
                string type2 = $3->print_Node();
                if(type1 != type2 && !(type1=="BYTE" && type2=="INT")){
                cout << "bad types\n";
                }
                
                output::printProductionRule(7);};

statement:  call SC 
            {output::printProductionRule(8);};

statement:  RETURN SC 
            {output::printProductionRule(9);};

statement:  IF openScopeMarker LPAREN exp RPAREN statement 
            {
                closeScope();
                output::printProductionRule(10);};

statement:  IF openScopeMarker LPAREN exp RPAREN statement ELSE openScopeMarker statement 
            {
                closeScope();
                output::printProductionRule(11);};

statement:  WHILE openScopeMarker LPAREN exp RPAREN statement 
            {
                closeScope();
                output::printProductionRule(12);};

statement:  BREAK SC 
            {output::printProductionRule(13);};

statement:  CONTINUE SC 
            {output::printProductionRule(14);};

call:       ID LPAREN exp RPAREN 
            {output::printProductionRule(15);};

type:       INT 
            {
                $$ = $1;
                output::printProductionRule(16);};

type:       BYTE 
            {
                $$ = $1;
                output::printProductionRule(17);};

type:       BOOL 
            {
                $$ = $1;
                output::printProductionRule(18);};

exp:        LPAREN exp RPAREN 
            {
                $$ = $2;
                output::printProductionRule(19);};

exp:        exp BINOP exp 
            {output::printProductionRule(20);};
            |
            exp MULT exp
            {output::printProductionRule(20);};

exp:        ID
            {
                Symtab::Table::Entry* entry = symtable.find($1->print_Node());
                if(!entry){
                    output::errorUndef(yylineno, $1->print_Node());
                    exit(1);
                }
                
                ((IdNode*)$1)->type = entry->type;

                $$ = $1;
                output::printProductionRule(21);}

exp:        call
            {output::printProductionRule(22);}

exp:        NUM
            {
                $$ = $1;
            }

exp:        NUM B
            {
                if(((NumNode*)$1)->num > 255){
                    output::errorByteTooLarge(yylineno, std::to_string(((NumNode*)$1)->num));
                    exit(1);
                }
                
                ((NumNode*)$1)->type = "BYTE";
                $$ = $1;
                output::printProductionRule(24);}

exp:        STRING
            {
                $$ = $1;
                output::printProductionRule(25);}

exp :       TRUE
            {
                $$ = $1;
                output::printProductionRule(26);};

exp:        FALSE
            {
                $$ = $1;
                output::printProductionRule(27);}

exp:        NOT exp
            {
                if($2->print_Node() != "BOOL"){
                    output::errorMismatch(yylineno);
                    exit(1);
                }

                $$ = $2;
                output::printProductionRule(28);}

exp:        exp AND exp
            {
                if($1->print_Node() != "BOOL" || $3->print_Node() != "BOOL"){
                    output::errorMismatch(yylineno);
                    exit(1);
                }

                $$ = $2;
                output::printProductionRule(29);}

exp:        exp OR exp
            {
                if($1->print_Node() != "BOOL" || $3->print_Node() != "BOOL"){
                    output::errorMismatch(yylineno);
                    exit(1);
                }

                $$ = $2;
                output::printProductionRule(30);}

exp:        exp RELATIONAL exp
            {
                if(($1->print_Node != "NUM") && ($1->print_Node() != "BYTE") || ($3->print_Node != "NUM") && ($3->print_Node() != "BYTE")){
                    output::errorMismatch(yylineno);
                    exit(1);
                }

                $$ = new TypeNode(yylineno, "BOOL");
                output::printProductionRule(31);}
            |
            exp EQUAL exp
            {
                if(($1->print_Node() != $3->print_Node()) || !($1->print_Node() == "NUM" && $3->print_Node() == "BYTE) || !($1->print_Node() == "BYTE" && $3->print_Node() == "NUM")) {
                    output::errorMismatch(yylineno);
                    exit(1);
                }

                $$ = new TypeNode(yylineno, "BOOL");
                output::printProductionRule(31);}

exp:        LPAREN type RPAREN exp
            {
                if(($2->print_Node != "INT") && ($2->print_Node() != "BYTE") || ($4->print_Node != "NUM") && ($4->print_Node() != "BYTE")){
                    output::errorMismatch(yylineno);
                    exit(1);
                }

                ((NumNode*)$4)->type = $2->print_Node();
                $$ = $4;
                output::printProductionRule(32);}


%%

int main() {
    return yyparse(); 
} 

int yyerror(const char* s)
{
    output::errorSyn(yylineno);
    exit(1);
    return 0;
}